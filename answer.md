# 简答题

## 2024

### 数组和结构的区别与联系

**区别**：

1. **元素类型**：数组中的元素必须是同一类型；结构体中的成员可以是不同类型。
2. **内存分配**：数组元素在内存中连续存储；结构体成员的内存布局可能因对齐规则存在间隙。
3. **访问方式**：数组通过下标访问元素（如 `arr[0]`）；结构体通过成员名访问（如 `s.member`）。
4. **赋值操作**：数组不能直接整体赋值（需逐元素操作）；结构体可以直接整体赋值（C99后支持）。

**联系**：

1. **复合数据类型**：二者均用于组织多个数据，可嵌套使用（如结构体包含数组，或数组元素为结构体）。
2. **内存连续性**：结构体的成员在内存中按声明顺序存储，类似数组的连续性（但可能存在对齐填充）。

### 判断含义

```c
int *p[];

int (*p)[];

int *p();

int (*p)();
```

1. **`int *p[];`**
   - **含义**：`p` 是一个数组，元素类型为 `int*`（指针数组）。
   - 例如：`int *p[5]` 表示长度为5的数组，每个元素指向 `int`。

2. **`int (*p)[];`**
   - **含义**：`p` 是一个指针，指向一个 `int` 类型的数组（数组指针）。
   - 例如：`int (*p)[3]` 表示 `p` 指向长度为3的 `int` 数组。

3. **`int *p();`**
   - **含义**：`p` 是一个函数，返回值类型为 `int*`（函数返回指针）。
   - 例如：`int *p()` 定义了一个返回 `int` 指针的函数。

4. **`int (*p)();`**
   - **含义**：`p` 是一个指针，指向一个返回 `int` 的函数（函数指针）。
   - 例如：`int (*p)(int)` 表示 `p` 指向接受一个 `int` 参数并返回 `int` 的函数。

### 改错题

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main()
{
    char *src = "hello,world";
    char *dest, *d, *p;
    int len, i;

    len = strlen(src); // strlen 返回的是真实字符串长度，不包含 '\0'
    dest = (char*)malloc(len); // 修正：分配足够的内存 -> len + 1 以容纳字符串结尾的 '\0'
    p = src[len]; // 修正：使 p 指向 src 的最后一个字符 -> len - 1
    d = dest;

    while (len-- != 0)
        d++ = p--; // 修正：正确地将 src 的字符逆序复制到 dest -> *(d++) = *(p--)

    // 补充：添加字符串结尾必须的 '\0' -> *d = '\0';
    printf("%s", dest);
}
```

### 静态变量和全局变量的区别；静态变量和普通局部变量的区别

#### 静态变量与全局变量

1. **作用域**：
   - 全局变量：整个程序可见（默认具有外部链接，可用 `extern` 跨文件访问）。
   - 静态全局变量：仅在定义它的文件内可见（内部链接）。
2. **初始化**：二者均默认初始化为0（若未显式初始化）。

#### 静态变量与普通局部变量

1. **生命周期**：
   - 静态局部变量：程序运行期间始终存在（仅初始化一次）。
   - 普通局部变量：函数调用时创建，退出时销毁。
2. **存储位置**：
   - 静态变量（包括全局和静态局部）存储在静态存储区（`.data` 或 `.bss`）。
   - 普通局部变量存储在栈区。
3. **初始化**：
   - 静态局部变量默认初始化为0；普通局部变量不初始化时值为随机值。

---

## 2023

### 1. C 语言执行效率措施

> 从 C 语言执行效率方便，简述下 C 语言采取了哪些措施提高执行效率。

C 语言通过以下措施提高执行效率：

- **编译型语言**：直接编译为机器码，减少解释执行的中间开销。
- **静态类型检查**：编译时确定类型，避免运行时类型判断。
- **指针和直接内存操作**：允许直接操作内存地址，减少数据拷贝。
- **底层控制**：支持寄存器变量、内联函数等优化，减少函数调用开销。
- **内存对齐**：通过结构体对齐优化内存访问速度。
- **高效循环和条件语句**：提供灵活的循环和跳转控制（如 `goto`），减少冗余操作。

### 2. 内存分配分析

> 根据下面的代码，填写表格。整数算 2 字节，字符 2 字节，指针 4 字节。每个区域的起始地址都是 0，内存按 2 字节编址。

```c
int num=2;

void main()
{
    char str1[2018] = {"UESTC"}; // 不记得这里几个字符了，反正就是要乘 2
    char* str2 = "CHENGDU";
    char p;
}

void func(int m)
{
    static int sta;
    int n = 10;
}
```

| 内存区域     | 常量或变量名       | 占用内存大小 |
|--------------|--------------------|--------------|
| 常量区       | `"CHENGDU"`        | 16 字节      |
| 常量区       | `"UESTC"`          | 12 字节      |
| 全局区       | `num`              | 2 字节       |
| 静态数据区   | `sta`（`func`中的静态变量） | 2 字节       |
| main 函数    | `str1[2018]`       | 4036 字节    |
| main 函数    | `str2`（指针）     | 4 字节       |
| main 函数    | `p`                | 2 字节       |
| func 函数    | `n`                | 2 字节       |
| func 函数    | `m`                | 2 字节       |

#### **内存区域划分说明**

- **常量区**：存储字符串字面量（如 `"CHENGDU"`、`"UESTC"`）等只读数据。
- **全局区**：存储全局变量（如 `num`）。
- **静态数据区**：存储静态变量（如 `sta`）。
- **栈区**：存储函数内的局部变量、参数和指针（如 `str1`、`str2`、`p`、`n`、`m`）。

#### **变量与常量的具体分配**

##### **1. 常量区**

| 变量/常量         | 大小计算                     | 占用内存大小 |
|-------------------|-----------------------------|--------------|
| `"CHENGDU"`       | 字符串长度：7字符 + `\0` = 8字符 × 2字节/字符 | **16 字节**  |
| `"UESTC"`         | 字符串长度：5字符 + `\0` = 6字符 × 2字节/字符 | **12 字节**  |

**说明**：

- 字符串字面量存储在只读的常量区。
- `str1` 数组的初始化值 `"UESTC"` 会从常量区拷贝到栈区，但原字符串仍存在于常量区。

##### **2. 全局区**

| 变量              | 类型         | 大小计算          | 占用内存大小 |
|-------------------|-------------|-------------------|--------------|
| `num`             | `int`       | `sizeof(int) = 2` | **2 字节**   |

**说明**：

- 全局变量 `num` 在程序启动时分配内存，生命周期持续到程序结束。

##### **3. 静态数据区**

| 变量              | 类型         | 大小计算          | 占用内存大小 |
|-------------------|-------------|-------------------|--------------|
| `sta`（静态变量） | `static int`| `sizeof(int) = 2` | **2 字节**   |

**说明**：

- `sta` 是 `func` 函数内的静态变量，存储在静态数据区，与函数调用无关，生命周期同全局变量。

##### **4. 栈区（`main` 函数）**

| 变量              | 类型           | 大小计算                     | 占用内存大小 |
|-------------------|---------------|-----------------------------|--------------|
| `str1[2018]`      | `char[]`      | `2018元素 × 2字节/字符`      | **4036 字节**|
| `str2`（指针）    | `char*`       | `sizeof(指针) = 4`          | **4 字节**   |
| `p`               | `char`        | `sizeof(char) = 2`          | **2 字节**   |

**说明**：

- `str1` 是局部数组，在 `main` 函数栈中分配，初始化时从常量区***拷贝*** `"UESTC"` 并填充剩余空间为 `0`。
- `str2` 是指针变量，指向常量区的 `"CHENGDU"`，自身占 4 字节（指针大小）。

##### **5. 栈区（`func` 函数）**

| 变量              | 类型         | 大小计算          | 占用内存大小 |
|-------------------|-------------|-------------------|--------------|
| `n`               | `int`       | `sizeof(int) = 2` | **2 字节**   |
| `m`（参数）       | `int`       | `sizeof(int) = 2` | **2 字节**   |

**说明**：

- `n` 是局部变量，`m` 是函数参数，均在 `func` 被调用时在栈区分配内存，函数返回后释放。

#### **关键错误修正**

- **数值字面量（如 `10`、`2018`、`2`）不存储在常量区**，而是直接嵌入代码或通过变量存储。
  - 例如：`2018` 是数组大小信息，存在于编译后的符号表中，不单独占用内存；`num=2` 的 `2` 存储在全局变量 `num` 的内存中。

#### **总结表格**

| 内存区域     | 变量/常量名              | 大小       |
|--------------|--------------------------|------------|
| 常量区       | `"CHENGDU"`              | 16 字节    |
| 常量区       | `"UESTC"`                | 12 字节    |
| 全局区       | `num`                    | 2 字节     |
| 静态数据区   | `sta`（`func`中的静态变量）| 2 字节    |
| main 栈区    | `str1[2018]`             | 4036 字节  |
| main 栈区    | `str2`（指针）           | 4 字节     |
| main 栈区    | `p`                      | 2 字节     |
| func 栈区    | `n`                      | 2 字节     |
| func 栈区    | `m`                      | 2 字节     |

**注**：内存分配基于题目假设（`int` 和 `char` 占 2 字节，指针占 4 字节）。实际实现可能因编译器和平台而异。

### 3. 循环结构分析

> `For(int i=0; nums[i] != temp; i++){printf("%d", i);}` 是什么结构? 使用显示结构语言该如何表示? 并标出条件跳转和强制跳转。

1. **结构类型**：条件分支结构（选择结构）。
2. **显示结构语言表示**：

   ```plaintext
   i = 0
   条件跳转（循环入口）：
     若 nums[i] == temp → 强制跳转到循环结束
     否则执行循环体：
         printf("%d", i)
         i++
         强制跳转回循环入口
   循环结束
   ```

3. **跳转标注**：
   - **条件跳转**：检查 `nums[i] != temp`，若条件不满足则跳出循环。
   - **强制跳转**：循环体执行后无条件跳转回循环入口。

### 4. 数组查找问题

在一个 array 数组里面找 item 变量

```c
scanf("%d", &item);
for (int numb = 0; array[numb] != item; numb++);
printf("%d", numb);
```

---

## 2019

### 请问用C语言编程实现网络数据传输，应该使用TCP/IP协议还是HTTP协议，为什么？

应使用**TCP/IP协议**。
**原因**：

- **协议层次**：TCP/IP是传输层协议，负责可靠的数据传输；HTTP是应用层协议，基于TCP/IP实现。
- **编程实现**：C语言通过套接字（Socket）直接操作传输层（TCP或UDP），而HTTP需要解析应用层协议格式，开发复杂度更高。
- **灵活性**：TCP/IP提供字节流传输，可自定义协议；HTTP固定了报文格式，适用于Web场景。

### 详细叙述一下一款客户定制的软件应该怎么进行测试，并交付使用

**测试步骤**：

1. **需求分析**：明确客户需求，制定测试计划。
2. **测试设计**：编写测试用例（功能、性能、安全等），覆盖所有需求。
3. **环境搭建**：部署与客户环境一致的测试平台。
4. **单元测试**：验证模块功能，使用白盒测试。
5. **集成测试**：检查模块间接口和数据流。
6. **系统测试**：整体验证功能、性能、兼容性等。
7. **用户验收测试（UAT）**：客户参与，确认软件符合预期。

**交付流程**：

1. **文档交付**：提供用户手册、技术文档、测试报告。
2. **培训支持**：指导客户使用及维护。
3. **维护服务**：修复后续发现的缺陷，提供升级支持。

---

## 2018

### 请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。（注：这里面还有个小题，float如何四舍五入转化成long类型）

1. **算术运算中的类型提升**：
   - 操作数类型不同时，低精度类型转为高精度类型（如`int`转`float`）。
2. **赋值时的类型转换**：
   - 右侧值类型自动转为左侧变量类型（如`float`赋值给`int`会截断小数）。
3. **函数调用传参**：
   - 实参类型与形参不匹配时，实参转为形参类型（如传递`int`给`float`形参）。
4. **返回值类型转换**：
   - 返回值类型与函数声明不一致时，自动转换（如返回`double`但声明为`int`）。

**float转long的四舍五入**：
C语言默认截断小数（向零取整），需手动实现四舍五入：

```c
long rounded = (long)(float_num + 0.5f);  // 正数适用，负数需额外处理
```

### 从C语言执行效率方便，简述下C语言除了指针、宏函数、位运算还采取了哪些措施提高执行效率

- **编译器优化**：启用`-O3`优化选项。
- **寄存器变量**：使用`register`关键字减少内存访问。
- **内联函数**：避免函数调用开销（`inline`）。
- **循环优化**：展开循环、减少分支预测失败。
- **内存对齐**：通过`#pragma pack`提升访问速度。
- **静态库链接**：减少动态链接开销。

### 数组越界会产生什么后果？

- **数据覆盖**：越界写入可能破坏其他变量或栈帧（导致程序崩溃）。
- **安全漏洞**：缓冲区溢出可能被利用执行恶意代码。
- **未定义行为**：结果不可预测，可能正常执行、崩溃或产生随机错误。

### 实参和形参都是数组元素；实参是数组地址，形参是指针；实参和形参都是数组地址问这三个都是什么传递方式

1. **实参和形参都是数组元素**：
   - **值传递**（传递单个元素的值）。
2. **实参是数组地址，形参是指针**：
   - **地址传递**（指针接收数组首地址）。
3. **实参和形参都是数组地址**：
   - **地址传递**（数组名退化为指针，传递首地址）。


